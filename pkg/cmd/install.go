package cmd

import (
	"bufio"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"os/user"
	"path"
	"strings"
	"syscall"
	"time"

	"github.com/spf13/cobra"
	"golang.org/x/crypto/ssh/terminal"
	"gopkg.in/yaml.v2"

	v1 "github.com/tinyzimmer/k3p/pkg/build/package/v1"
	"github.com/tinyzimmer/k3p/pkg/cluster"
	"github.com/tinyzimmer/k3p/pkg/cluster/node"
	"github.com/tinyzimmer/k3p/pkg/install"
	"github.com/tinyzimmer/k3p/pkg/log"
	"github.com/tinyzimmer/k3p/pkg/types"
)

var (
	installNodeRole        string
	installDocker          bool
	installWriteKubeconfig string
	installValuesFile      string
	installValues          []string
	installAcceptDefaults  bool
	installOpts            types.InstallOptions
	installConnectOpts     types.NodeConnectOptions
	installDockerOpts      types.DockerClusterOptions
)

func init() {

	var currentUser *user.User
	var err error
	if currentUser, err = user.Current(); err != nil {
		log.Fatal(err)
	}

	installCmd.Flags().StringVarP(&installValuesFile, "values", "f", "", "An optional json or yaml file containing key-value pairs of package configurations")
	installCmd.Flags().StringArrayVar(&installValues, "set", []string{}, "Values to set to configurations in the package in the format of --set <name>=<value>")
	installCmd.Flags().BoolVar(&installAcceptDefaults, "accept-defaults", false, "Accept the defaults for any package configurations, default behavior is to prompt for all unprovided values")

	installCmd.MarkFlagFilename("values", "json", "yaml", "yml")
	installCmd.RegisterFlagCompletionFunc("set", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		log.Verbose = false
		f, err := os.Open(args[0])
		if err != nil {
			return nil, cobra.ShellCompDirectiveError
		}
		defer f.Close()
		pkg, err := v1.Load(f)
		if err != nil {
			return nil, cobra.ShellCompDirectiveError
		}
		defer pkg.Close()
		cfg := pkg.GetMeta().GetPackageConfig()
		out := make([]string, len(cfg.Variables))
		for i, vari := range cfg.Variables {
			if !strings.HasPrefix(toComplete, vari.Name) {
				out[i] = fmt.Sprintf("%s=", vari.Name)
			}
		}
		return out, cobra.ShellCompDirectiveNoSpace
	})

	installCmd.Flags().StringVarP(&installOpts.NodeName, "node-name", "n", "", "An optional name to give this node in the cluster")
	installCmd.Flags().IntVar(&installOpts.APIListenPort, "api-port", 6443, "The port for the k3s server to bind to")
	installCmd.Flags().BoolVar(&installOpts.AcceptEULA, "accept-eula", false, "Automatically accept any EULA included with the package")
	installCmd.Flags().StringVarP(&installOpts.ServerURL, "join", "j", "", "When installing an agent instance, the address of the server to join (e.g. https://myserver:6443)")
	installCmd.Flags().StringVarP(&installNodeRole, "join-role", "r", "agent", `Specify whether to join the cluster as a "server" or "agent"`)
	installCmd.Flags().StringVarP(&installOpts.NodeToken, "join-token", "t", "", `When installing an additional agent or server instance, the node token to use.

For new agents, this can be retrieved with "k3p token get agent" or in 
"/var/lib/rancher/k3s/server/node-token" on any of the server instances.
For new servers, this value was either provided to or generated by 
"k3s install --init-ha" and can be retrieved from that server with 
"k3p token get server". When used with --init-ha, the provided token will 
be used for registering new servers, instead of one being generated.`)

	installCmd.RegisterFlagCompletionFunc("join-role", completeStringOpts([]string{"server", "agent"}))

	installCmd.Flags().StringVar(&installOpts.ResolvConf, "resolv-conf", "", `The path of a resolv-conf file to use when configuring DNS in the cluster.
When used with the --host flag, the path must reside on the remote system (this will change in the future).`)

	installCmd.Flags().StringVar(&installWriteKubeconfig, "write-kubeconfig", "", "Write a copy of the admin client to this file")
	installCmd.Flags().StringVar(&installOpts.KubeconfigMode, "kubeconfig-mode", "", "The mode to set on the k3s kubeconfig. Default is to only allow root access")

	installCmd.Flags().StringArrayVar(&installOpts.K3sServerArgs, "k3s-server-arg", []string{}, `Extra arguments to pass to the k3s server process, for more details see:
https://rancher.com/docs/k3s/latest/en/installation/install-options/server-config
`)
	installCmd.Flags().StringArrayVar(&installOpts.K3sAgentArgs, "k3s-agent-arg", []string{}, `Extra arguments to pass to the k3s agent process, for more details see:
https://rancher.com/docs/k3s/latest/en/installation/install-options/agent-config
`)
	installCmd.Flags().BoolVar(&installOpts.InitHA, "init-ha", false, `When set, this server will run with the --cluster-init flag to enable clustering, 
and a token will be generated for adding additional servers to the cluster with 
"--join-role server". You may optionally use the --join-token flag to provide a 
pre-generated one.`)

	// Remote installation options

	var defaultKeyArg string
	defaultKeyPath := path.Join(currentUser.HomeDir, ".ssh", "id_rsa")
	if _, err := os.Stat(defaultKeyPath); err == nil {
		defaultKeyArg = defaultKeyPath
	}

	installCmd.Flags().StringVarP(&installConnectOpts.Address, "host", "H", "", "The IP or DNS name of a remote host to perform the installation against")
	installCmd.Flags().StringVarP(&installConnectOpts.SSHUser, "ssh-user", "u", currentUser.Username, "The username to use when authenticating against the remote host")
	installCmd.Flags().StringVarP(&installConnectOpts.SSHKeyFile, "private-key", "k", defaultKeyArg, `The path to a private key to use when authenticating against the remote host, 
if not provided you will be prompted for a password`)
	installCmd.Flags().IntVarP(&installConnectOpts.SSHPort, "ssh-port", "P", 22, "The port to use when connecting to the remote host over SSH")

	// Docker options
	installCmd.Flags().BoolVarP(&installDocker, "docker", "D", false, "Install the package to a docker container on the local system.")
	installCmd.Flags().StringVar(&installDockerOpts.ClusterName, "cluster-name", "", "DOCKER ONLY: Override the name of the cluster (defaults to the package name)")
	installCmd.Flags().IntVar(&installDockerOpts.Servers, "servers", 1, "DOCKER ONLY: The number of servers to run in the cluster")
	installCmd.Flags().IntVar(&installDockerOpts.Agents, "agents", 0, "DOCKER ONLY: The number of agents to run in the cluster")
	installCmd.Flags().StringArrayVarP(&installDockerOpts.PortMappings, "publish", "p", []string{}, "DOCKER ONLY: Additional port mappings in the same format as used for k3d")

	rootCmd.AddCommand(installCmd)
}

var installCmd = &cobra.Command{
	Use:   "install PACKAGE",
	Short: "Install the given package to the system",
	Long: `
The install command can be used to distribute a package built with "k3p build".

The command takes a single argument (with optional flags) of the filesystem path or web URL
where the package resides. Additional flags provide the ability to initialize clustering (HA),
join existing servers, or pass custom arguments to the k3s agent/server processes.

Example

	$> k3p install /path/on/filesystem.tar
	$> k3p install https://example.com/package.tar

When running on the local system like above, you will need to have root privileges. You can also 
direct the installation at a remote system over SSH via the --host flag. This will require the 
remote user having passwordless sudo available to them.

    $> k3p install package.tar --host 192.168.1.100 [SSH_FLAGS]

See the help below for additional information on available flags.
`,
	Args: cobra.ExactArgs(1),
	ValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		return []string{"tar"}, cobra.ShellCompDirectiveFilterFileExt
	},
	RunE: func(cmd *cobra.Command, args []string) error {
		// check the node role to make sure it's valid if relevant
		if installOpts.ServerURL != "" && installNodeRole != "" {
			switch types.K3sRole(installNodeRole) {
			case types.K3sRoleServer:
				installOpts.K3sRole = types.K3sRoleServer
			case types.K3sRoleAgent:
				installOpts.K3sRole = types.K3sRoleAgent
			default:
				return fmt.Errorf("%q is not a valid node role", installNodeRole)
			}
		}

		// Retrieve the package from the command line
		pkg, err := getPackage(args[0])
		if err != nil {
			return err
		}

		pkgMeta := pkg.GetMeta()

		// Do validations on any docker options
		if installDocker {
			installDockerOpts.K3sVersion = pkgMeta.GetK3sVersion()
			if installDockerOpts.ClusterName == "" {
				installDockerOpts.ClusterName = pkgMeta.GetName()
			}
			if installDockerOpts.Servers&1 != 1 {
				return errors.New("Docker node servers must be an odd number")
			}
			if installDockerOpts.Servers > 1 {
				installOpts.InitHA = true
			}
		}

		// Get the node to run the installation against
		target, err := getTargetNode(pkg)
		if err != nil {
			return err
		}

		defer target.Close()

		// Check if we are performing any variable substitution
		if config := pkgMeta.GetPackageConfig(); config != nil {
			installOpts.Variables, err = gatherConfigVariables(config)
			if err != nil {
				return err
			}
		}

		// run the installation
		err = install.New().Install(target, pkg, &installOpts)
		if err != nil {
			return err
		}

		// If docker, add any extra nodes and configure the load balancer
		if installDocker {
			if err := setupDockerCluster(target, pkg); err != nil {
				return err
			}
		}

		// Retrieve and write a copy of the kubeconfig if requested
		if installWriteKubeconfig != "" {
			if err := writeKubeconfig(target); err != nil {
				return err
			}
		}

		logCompletion(target)
		return nil
	},
}

func logCompletion(target types.Node) {
	log.Info("The cluster has been installed")
	if installConnectOpts.Address != "" {
		log.Infof("You can view the cluster by connecting to %s and running `k3s kubectl cluster-info`\n", installConnectOpts.Address)
	} else if !installDocker {
		log.Info("You can view the cluster by running `k3s kubectl cluster-info`")
	} else {
		if installWriteKubeconfig != "" {
			log.Infof("You can view the cluster by running `kubectl --kubeconfig %s cluster-info`\n", installWriteKubeconfig)
		} else {
			if name, err := target.GetK3sAddress(); err == nil {
				log.Infof("You can retrieve the kubeconfig by running `docker cp %s:%s ./kubeconfig.yaml`\n", name, types.K3sKubeconfig)
			}
		}
	}
}

func gatherConfigVariables(cfg *types.PackageConfig) (map[string]string, error) {
	vars := make(map[string]string)
	if installValuesFile != "" {
		body, err := ioutil.ReadFile(installValuesFile)
		if err != nil {
			return nil, err
		}
		if strings.HasSuffix(installValuesFile, ".json") {
			err = json.Unmarshal(body, &vars)
		} else if strings.HasSuffix(installValuesFile, ".yaml") || strings.HasSuffix(installValuesFile, ".yml") {
			err = yaml.Unmarshal(body, &vars)
		} else {
			err = fmt.Errorf("Not a valid json or yaml file: %q", installValuesFile)
		}
		if err != nil {
			return nil, err
		}
	}
	for _, val := range installValues {
		spl := strings.Split(val, "=")
		if len(spl) != 2 {
			return nil, fmt.Errorf("Invalid argument to --set %q", val)
		}
		vars[spl[0]] = spl[1]
	}
	for _, vari := range cfg.Variables {
		if _, ok := vars[vari.Name]; !ok {
			if vari.Default != "" && installAcceptDefaults {
				vars[vari.Name] = vari.Default
				continue
			}
			var prompt string
			if vari.Prompt != "" {
				prompt = fmt.Sprintf("%s [%s]: ", vari.Prompt, vari.Default)
			} else {
				prompt = fmt.Sprintf("Please provide a value for %s [%s]: ", vari.Name, vari.Default)
			}
			scanner := bufio.NewScanner(os.Stdin)
			fmt.Printf(prompt)
			scanner.Scan()
			if res := scanner.Text(); res != "" {
				vars[vari.Name] = res
			} else {
				vars[vari.Name] = vari.Default
			}
		}
	}
	return vars, nil
}

func getTargetNode(pkg types.Package) (types.Node, error) {
	if installConnectOpts.Address != "" {
		if installConnectOpts.SSHKeyFile == "" {
			fmt.Printf("Enter SSH Password for %s: ", installConnectOpts.SSHUser)
			bytePassword, err := terminal.ReadPassword(int(syscall.Stdin))
			if err != nil {
				return nil, err
			}
			installConnectOpts.SSHPassword = string(bytePassword)
		}
		return node.Connect(&installConnectOpts)
	}
	if installDocker {
		target, err := node.NewDocker(&types.DockerNodeOptions{
			ClusterOptions: &installDockerOpts,
			NodeIndex:      0,
			NodeRole:       types.K3sRoleServer,
		})
		if err != nil {
			return nil, err
		}
		if target.(*node.Docker).IsK3sRunning() {
			return nil, fmt.Errorf("Package %q is already running on the sytem", pkg.GetMeta().GetName())
		}
		return target, nil
	}
	// make sure we are root
	usr, err := user.Current()
	if err != nil {
		return nil, err
	}
	if usr.Uid != "0" {
		return nil, errors.New("Local install must be run as root")
	}
	return node.Local(), nil
}

func writeKubeconfig(target types.Node) error {
	log.Info("Waiting for server to write the admin kubeconfig")

	var kubeconfigStr string

	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(30)*time.Second)
	defer cancel()

GetKubeconfig:
	for {
		select {
		case <-ctx.Done():
			return errors.New("Timeout reached waiting for server to write kubeconfig")
		default:
			rdr, err := target.GetFile(types.K3sKubeconfig)
			if err != nil {
				log.Debug("Error retrieving kubeconfig, will try again:", err)
				time.Sleep(time.Duration(1) * time.Second)
				continue
			}
			defer rdr.Close()
			body, err := ioutil.ReadAll(rdr)
			if err != nil {
				return err
			}
			kubeconfigStr = string(body)
			break GetKubeconfig
		}
	}

	if installConnectOpts.Address != "" {
		kubeconfigStr = strings.Replace(kubeconfigStr, "127.0.0.1", installConnectOpts.Address, 1)
	}
	log.Infof("Writing the kubeconfig to %q\n", installWriteKubeconfig)
	return ioutil.WriteFile(installWriteKubeconfig, []byte(kubeconfigStr), 0644)
}

func setupDockerCluster(leader types.Node, pkg types.Package) error {
	clusterManager := cluster.New(leader)
	// Create additional servers
	if installDockerOpts.Servers > 1 {
		opts := &types.AddNodeOptions{
			NodeRole: types.K3sRoleServer,
		}
		for i := 1; i < installDockerOpts.Servers; i++ {
			server, err := node.NewDocker(&types.DockerNodeOptions{
				ClusterOptions: &installDockerOpts,
				NodeIndex:      i,
				NodeRole:       types.K3sRoleServer,
			})
			if err != nil {
				return err
			}
			if err := clusterManager.AddNode(server, opts); err != nil {
				return err
			}
		}
	}

	// Create any additional agents
	if installDockerOpts.Agents > 0 {
		// Wait for the node token to get written to the system
		log.Info("Waiting for k3s to write the server node-token")
		ctx, cancel := context.WithTimeout(context.Background(), time.Duration(30)*time.Second)
		defer cancel()
	GetNodeToken:
		for {
			select {
			case <-ctx.Done():
				return errors.New("Timeout reached waiting for server to write node-token")
			default:
				_, err := leader.GetFile(types.AgentTokenFile)
				if err != nil {
					log.Debug("Error retrieving node token, will try again:", err)
					time.Sleep(time.Duration(1) * time.Second)
					continue
				}
				break GetNodeToken
			}
		}
		opts := &types.AddNodeOptions{
			NodeRole: types.K3sRoleAgent,
		}
		for i := 0; i < installDockerOpts.Agents; i++ {
			server, err := node.NewDocker(&types.DockerNodeOptions{
				ClusterOptions: &installDockerOpts,
				NodeIndex:      i,
				NodeRole:       types.K3sRoleAgent,
			})
			if err != nil {
				return err
			}
			if err := clusterManager.AddNode(server, opts); err != nil {
				return err
			}
		}
	}
	// Create an lb
	lb, err := node.NewDocker(&types.DockerNodeOptions{
		ClusterOptions: &installDockerOpts,
		NodeRole:       types.K3sRoleLoadBalancer,
	})
	if err != nil {
		return err
	}

	return lb.Execute(installOpts.ToExecOpts(pkg.GetMeta().GetPackageConfig()))
}

// yea its ugly ill fix
func getPackage(path string) (types.Package, error) {
	if strings.HasPrefix(path, "http") {
		log.Info("Downloading the archive from", path)
		resp, err := http.Get(path)
		if err != nil {
			return nil, err
		}
		defer resp.Body.Close()
		log.Info("Loading the archive")
		if strings.HasSuffix(path, ".zst") {
			dec, err := v1.Decompress(resp.Body)
			if err != nil {
				return nil, err
			}
			return v1.Load(dec)
		}
		return v1.Load(resp.Body)
	}
	log.Info("Loading the archive")
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	if strings.HasSuffix(path, ".zst") {
		dec, err := v1.Decompress(f)
		if err != nil {
			return nil, err
		}
		return v1.Load(dec)
	}
	return v1.Load(f)
}
