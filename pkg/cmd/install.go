package cmd

import (
	"context"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"os/user"
	"path"
	"strings"
	"syscall"
	"time"

	"github.com/spf13/cobra"
	"golang.org/x/crypto/ssh/terminal"

	v1 "github.com/tinyzimmer/k3p/pkg/build/package/v1"
	"github.com/tinyzimmer/k3p/pkg/cluster"
	"github.com/tinyzimmer/k3p/pkg/cluster/node"
	"github.com/tinyzimmer/k3p/pkg/install"
	"github.com/tinyzimmer/k3p/pkg/log"
	"github.com/tinyzimmer/k3p/pkg/types"
)

var (
	nodeRole               string
	installDocker          bool
	installWriteKubeconfig string
	installOpts            *types.InstallOptions
	installConnectOpts     *types.NodeConnectOptions
	installDockerOpts      *types.DockerClusterOptions
)

func init() {
	installOpts = &types.InstallOptions{}
	installConnectOpts = &types.NodeConnectOptions{}
	installDockerOpts = &types.DockerClusterOptions{}

	installCmd.Flags().StringVarP(&installOpts.NodeName, "node-name", "n", "", "An optional name to give this node in the cluster")
	installCmd.Flags().BoolVar(&installOpts.AcceptEULA, "accept-eula", false, "Automatically accept any EULA included with the package")
	installCmd.Flags().StringVarP(&installOpts.ServerURL, "join", "j", "", "When installing an agent instance, the address of the server to join (e.g. https://myserver:6443)")
	installCmd.Flags().StringVarP(&nodeRole, "join-role", "r", "agent", `Specify whether to join the cluster as a "server" or "agent"`)
	installCmd.Flags().StringVarP(&installOpts.NodeToken, "join-token", "t", "", `When installing an additional agent or server instance, the node token to use.

For new agents, this can be retrieved with "k3p token get agent" or in 
"/var/lib/rancher/k3s/server/node-token" on any of the server instances.
For new servers, this value was either provided to or generated by 
"k3s install --init-ha" and can be retrieved from that server with 
"k3p token get server". When used with --init-ha, the provided token will 
be used for registering new servers, instead of one being generated.`)

	installCmd.Flags().StringVar(&installOpts.ResolvConf, "resolv-conf", "", `The path of a resolv-conf file to use when configuring DNS in the cluster.
When used with the --host flag, the path must reside on the remote system (this will change in the future).`)

	installCmd.Flags().StringVar(&installWriteKubeconfig, "write-kubeconfig", "", "Write a copy of the admin client to this file")
	installCmd.Flags().StringVar(&installOpts.KubeconfigMode, "kubeconfig-mode", "", "The mode to set on the k3s kubeconfig. Default is to only allow root access")

	installCmd.Flags().StringVar(&installOpts.K3sExecArgs, "k3s-exec", "", `Extra arguments to pass to the k3s server or agent process, for more details see:
https://rancher.com/docs/k3s/latest/en/installation/install-options/server-config
`)
	installCmd.Flags().BoolVar(&installOpts.InitHA, "init-ha", false, `When set, this server will run with the --cluster-init flag to enable clustering, 
and a token will be generated for adding additional servers to the cluster with 
"--join-role server". You may optionally use the --join-token flag to provide a 
pre-generated one.`)

	// Remote installation options

	u, err := user.Current()
	if err != nil {
		log.Fatal(err)
	}

	var defaultKeyArg string
	defaultKeyPath := path.Join(u.HomeDir, ".ssh", "id_rsa")
	if _, err := os.Stat(defaultKeyPath); err == nil {
		defaultKeyArg = defaultKeyPath
	}

	installCmd.Flags().StringVarP(&installConnectOpts.Address, "host", "H", "", "The IP or DNS name of a remote host to perform the installation against")
	installCmd.Flags().StringVarP(&installConnectOpts.SSHUser, "ssh-user", "u", u.Username, "The username to use when authenticating against the remote host")
	installCmd.Flags().StringVarP(&installConnectOpts.SSHKeyFile, "private-key", "k", defaultKeyArg, `The path to a private key to use when authenticating against the remote host, 
if not provided you will be prompted for a password`)
	installCmd.Flags().IntVarP(&installConnectOpts.SSHPort, "ssh-port", "p", 22, "The port to use when connecting to the remote host over SSH")

	// Docker options
	installCmd.Flags().BoolVarP(&installDocker, "docker", "D", false, "Install the package to a docker container on the local system.")
	installCmd.Flags().StringVar(&installDockerOpts.ClusterName, "cluster-name", "", "DOCKER ONLY: Override the name of the cluster (defaults to the package name)")
	installCmd.Flags().IntVar(&installDockerOpts.Servers, "servers", 1, "DOCKER ONLY: The number of servers to run in the cluster")
	installCmd.Flags().IntVar(&installDockerOpts.Agents, "agents", 0, "DOCKER ONLY: The number of agents to run in the cluster")
	installCmd.Flags().IntVar(&installDockerOpts.APIPort, "api-port", 6443, "DOCKER ONLY: The port to bind to the k3s API server")
	installCmd.Flags().StringSliceVar(&installDockerOpts.PortMappings, "map-ports", []string{}, "DOCKER ONLY: Additional port mappings to apply to the leader node")

	rootCmd.AddCommand(installCmd)
}

var installCmd = &cobra.Command{
	Use:   "install PACKAGE",
	Short: "Install the given package to the system",
	Long: `
The install command can be used to distribute a package built with "k3p build".

The command takes a single argument (with optional flags) of the filesystem path or web URL
where the package resides. Additional flags provide the ability to initialize clustering (HA),
join existing servers, or pass custom arguments to the k3s agent/server processes.

Example

	$> k3p install /path/on/filesystem.tar
	$> k3p install https://example.com/package.tar

When running on the local system like above, you will need to have root privileges. You can also 
direct the installation at a remote system over SSH via the --host flag. This will require the 
remote user having passwordless sudo available to them.

    $> k3p install package.tar --host 192.168.1.100 [SSH_FLAGS]

See the help below for additional information on available flags.
`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		// Retrieve the package from the command line
		pkg, err := getPackage(args[0])
		if err != nil {
			return err
		}

		// check the node role to make sure it's valid if relevant
		if installOpts.ServerURL != "" && nodeRole != "" {
			switch types.K3sRole(nodeRole) {
			case types.K3sRoleServer:
				installOpts.K3sRole = types.K3sRoleServer
			case types.K3sRoleAgent:
				installOpts.K3sRole = types.K3sRoleAgent
			default:
				return fmt.Errorf("%q is not a valid node role", nodeRole)
			}
		}

		// Do validations on any docker options
		if installDocker {
			installDockerOpts.K3sVersion = pkg.GetMeta().GetK3sVersion()
			if installDockerOpts.ClusterName == "" {
				installDockerOpts.ClusterName = pkg.GetMeta().GetName()
			}
			if installDockerOpts.Servers&1 != 1 {
				return errors.New("Docker node servers must be an odd number")
			}
			if installDockerOpts.Servers > 1 {
				installOpts.InitHA = true
			}
		}

		// Get the node to run the installation against
		target, err := getTargetNode(pkg)
		if err != nil {
			return err
		}

		defer target.Close()

		// run the installation
		err = install.New().Install(target, pkg, installOpts)
		if err != nil {
			return err
		}

		// If docker, add any extra nodes and configure the load balancer
		if installDocker {
			if err := setupDockerCluster(target); err != nil {
				return err
			}
		}

		// Retrieve and write a copy of the kubeconfig if requested
		if installWriteKubeconfig != "" {
			if err := writeKubeconfig(target); err != nil {
				return err
			}
		}

		logCompletion(target)
		return nil
	},
}

func logCompletion(target types.Node) {
	log.Info("The cluster has been installed")
	if installConnectOpts.Address != "" {
		log.Infof("You can view the cluster by connecting to %s and running `k3s kubectl cluster-info`\n", installConnectOpts.Address)
	} else if !installDocker {
		log.Info("You can view the cluster by running `k3s kubectl cluster-info`")
	} else {
		if installWriteKubeconfig != "" {
			log.Infof("You can view the cluster by running `kubectl --kubeconfig %s cluster-info`\n", installWriteKubeconfig)
		} else {
			if name, err := target.GetK3sAddress(); err == nil {
				log.Infof("You can retrieve the kubeconfig by running `docker cp %s:%s ./kubeconfig.yaml`\n", name, types.K3sKubeconfig)
			}
		}
	}
}

func getTargetNode(pkg types.Package) (types.Node, error) {
	if installConnectOpts.Address != "" {
		if installConnectOpts.SSHKeyFile == "" {
			fmt.Printf("Enter SSH Password for %s: ", installConnectOpts.SSHUser)
			bytePassword, err := terminal.ReadPassword(int(syscall.Stdin))
			if err != nil {
				return nil, err
			}
			installConnectOpts.SSHPassword = string(bytePassword)
		}
		return node.Connect(installConnectOpts)
	}
	if installDocker {
		target, err := node.NewDocker(&types.DockerNodeOptions{
			ClusterOptions: installDockerOpts,
			NodeIndex:      0,
			NodeRole:       types.K3sRoleServer,
		})
		if err != nil {
			return nil, err
		}
		if target.(*node.Docker).IsK3sRunning() {
			return nil, fmt.Errorf("Package %q is already running on the sytem", pkg.GetMeta().GetName())
		}
		return target, nil
	}
	// make sure we are root
	usr, err := user.Current()
	if err != nil {
		return nil, err
	}
	if usr.Uid != "0" {
		return nil, errors.New("Local install must be run as root")
	}
	return node.Local(), nil
}

func writeKubeconfig(target types.Node) error {
	log.Info("Waiting for server to write the admin kubeconfig")

	var kubeconfigStr string

	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(30)*time.Second)
	defer cancel()

GetKubeconfig:
	for {
		select {
		case <-ctx.Done():
			return errors.New("Timeout reached waiting for server to write kubeconfig")
		default:
			rdr, err := target.GetFile(types.K3sKubeconfig)
			if err != nil {
				log.Debug("Error retrieving kubeconfig, will try again:", err)
				time.Sleep(time.Duration(1) * time.Second)
				continue
			}
			defer rdr.Close()
			body, err := ioutil.ReadAll(rdr)
			if err != nil {
				return err
			}
			kubeconfigStr = string(body)
			break GetKubeconfig
		}
	}

	if installConnectOpts.Address != "" {
		kubeconfigStr = strings.Replace(kubeconfigStr, "127.0.0.1", installConnectOpts.Address, 1)
	} else if installDocker {
		kubeconfigStr = strings.Replace(kubeconfigStr, "127.0.0.1:6443", fmt.Sprintf("127.0.0.1:%d", installDockerOpts.APIPort), 1)
	}
	log.Infof("Writing the kubeconfig to %q\n", installWriteKubeconfig)
	return ioutil.WriteFile(installWriteKubeconfig, []byte(kubeconfigStr), 0644)
}

func setupDockerCluster(leader types.Node) error {
	clusterManager := cluster.New(leader)
	// Create additional servers
	if installDockerOpts.Servers > 1 {
		opts := &types.AddNodeOptions{
			NodeRole: types.K3sRoleServer,
		}
		for i := 1; i < installDockerOpts.Servers; i++ {
			server, err := node.NewDocker(&types.DockerNodeOptions{
				ClusterOptions: installDockerOpts,
				NodeIndex:      i,
				NodeRole:       types.K3sRoleServer,
			})
			if err != nil {
				return err
			}
			if err := clusterManager.AddNode(server, opts); err != nil {
				return err
			}
		}
	}

	// Create any additional agents
	if installDockerOpts.Agents > 0 {
		// Wait for the node token to get written to the system
		log.Info("Waiting for k3s to write the server node-token")
		ctx, cancel := context.WithTimeout(context.Background(), time.Duration(30)*time.Second)
		defer cancel()
	GetNodeToken:
		for {
			select {
			case <-ctx.Done():
				return errors.New("Timeout reached waiting for server to write node-token")
			default:
				_, err := leader.GetFile(types.AgentTokenFile)
				if err != nil {
					log.Debug("Error retrieving node token, will try again:", err)
					time.Sleep(time.Duration(1) * time.Second)
					continue
				}
				break GetNodeToken
			}
		}
		opts := &types.AddNodeOptions{
			NodeRole: types.K3sRoleAgent,
		}
		for i := 0; i < installDockerOpts.Agents; i++ {
			server, err := node.NewDocker(&types.DockerNodeOptions{
				ClusterOptions: installDockerOpts,
				NodeIndex:      i,
				NodeRole:       types.K3sRoleAgent,
			})
			if err != nil {
				return err
			}
			if err := clusterManager.AddNode(server, opts); err != nil {
				return err
			}
		}
	}
	// Create an lb
	lb, err := node.NewDocker(&types.DockerNodeOptions{
		ClusterOptions: installDockerOpts,
		NodeRole:       types.K3sRoleLoadBalancer,
	})
	if err != nil {
		return err
	}

	return lb.Execute(&types.ExecuteOptions{})
}

func getPackage(path string) (types.Package, error) {
	if strings.HasPrefix(path, "http") {
		log.Info("Downloading the archive from", path)
		resp, err := http.Get(path)
		if err != nil {
			return nil, err
		}
		defer resp.Body.Close()
		log.Info("Loading the archive")
		return v1.Load(resp.Body)
	}
	log.Info("Loading the archive")
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return v1.Load(f)
}
